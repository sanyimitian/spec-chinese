# GitHub Spec Kit（spec-kit）怎么用：在 Codex 里运行哪些命令、怎么传参、分别有什么作用

首先在终端执行以下命令，让codex可以识别 Spec Kit 的命令

export CODEX_HOME=【Spec Kit 初始化出来的项目目录】/.codex

例如：export CODEX_HOME=/home/pan/Desktop/code/work_weixin_agent_entry/.codex
> 流水线：**宪章（长期规则）→ 规格说明（本次要做什么）→（可选）澄清问题 → 技术方案 → 任务拆解 → 实施落地**。

- **初始化宪章（长期规则）**：`/speckit.constitution ...`
- **生成规格说明（本次功能需求 + 验收标准）**：`/speckit.specify ...`
- **（可选）需求澄清（提问补全不确定点）**：`/speckit.clarify ...`
- **规划技术方案（怎么实现）**：`/speckit.plan ...`
- **拆解任务（施工清单/工单化）**：`/speckit.tasks`
- **实施交付（写代码 + 验证）**：`/speckit.implement`

参考示例：
## 示例步骤1.项目宪章（长期规则）：
/speckit.constitution 
我希望为本项目建立一套可长期维护、可审计、可自动化执行的工程规范。请将以下内容固化为“不可协商的长期规则”，并在宪章中明确 必须/应该、例外流程与验收口径。若有缺失信息，用 待办 标注并给出推荐默认值。

### 0) 项目基本信息（用于上下文）
- 项目名称/领域：[PROJECT_NAME]
- 主要语言与版本：[LANG]

- 部署形态：[web/service/cli/library/mobile]
- 目标环境：[browser/node/linux/k8s/etc]

### 1) 代码风格与静态规范（可自动化）
必须：
- 统一格式化工具与规则，保证“保存即格式化/一键 format”可用。
- 统一 lint 规则，避免团队成员差异；新增规则需解释收益与迁移成本。
- 禁止提交明显的代码异味：未使用变量/死代码/重复实现/不可达分支（以 lint/编译器为准）。
#### 质量与可维护性强约束（必须遵守，禁止偷懒）
##### 1) 旧功能替换后必须清理旧代码
- 硬规则：新功能取代旧功能时，必须同步清理旧入口、旧调用链、旧配置、旧分支、旧测试。
- 验收要求：不得留下无人调用/不可达分支/仅注释说明未删除的旧实现。
- 例外条件：允许灰度/回滚时短期保留，但必须标注 DEPRECATED（含删除计划/期限/迁移说明/开关位），并记录清理计划。

##### 2) 禁止臆造字段/参数/配置做兜底
- 硬规则：不得假设不存在的字段/参数/配置；新增字段必须在契约/字典中定义并同步测试。
- 验收要求：代码中出现的入参字段必须可在契约或数据字典中追溯。
- 例外条件：仅对契约明确为可选字段做兜底，且必须可追踪（日志/指标/错误码）。

##### 3) 禁止“只对示例有效”的点修复
- 硬规则：默认类修复；点修复必须显式声明。
- 验收要求：类修复必须覆盖示例 + ≥2 变体 + ≥1 反例。
- 例外条件：仅在需求明确声明点修复且有合理原因时允许。



应该：
- 控制单文件与函数复杂度（如：限制函数长度/圈复杂度，或通过审查强制拆分）。
- 对公共 API/核心模块启用更严格规则（如 no-implicit-any、strict 等按语言栈）。

### 2) 架构与目录结构
必须：
- 目录结构清晰、分层明确（例如 domain/service/infra/ui 等；按项目形态选择）。
- 禁止跨层“反向依赖”和隐式耦合；公共能力下沉到明确的公共模块。
- 公共接口（API/SDK/组件）必须有清晰边界与版本/兼容性策略（哪怕是 v0 也要写清楚）。

### 3) 安全与隐私（适用于所有项目）
必须：
- 严禁提交密钥、token、私钥、生产凭据；必须提供安全的本地配置方式（.env 或 secret manager）。
- 日志不得输出敏感信息（token/密码/PII）；必要时脱敏。
- 所有外部输入必须校验与安全处理（注入/路径遍历/XSS/CSRF/SSRFi 等按形态选择）。
应该：
- 对高风险接口/功能做威胁建模的最小化记录（哪怕只有几条要点）。
待办：
- 敏感信息范围定义：[SENSITIVE_FIELDS]

### 4) 性能与稳定性
必须：
- 关键路径必须有错误处理与可观测的失败信号（明确返回/错误码/日志/提示错误信息）。
- 禁止明显的性能陷阱（N+1、无界循环/递归、无界队列/缓存等），对潜在风险给出保护上限。
应该：
- 为核心指标设定目标与验证方式（响应时间/资源占用/包体积/启动时间等按形态选择）。
待办：
- 性能目标与验证命令：[PERF_TARGETS + PERF_CMDS]

### 5) 可观测性与运维（服务类项目更重要）
必须（若为 service）：
- 结构化日志；关键请求/任务要有 trace/correlation id（或等价方案）。
- 关键错误必须可定位（日志 + 关键上下文 + 可重放信息，且不泄露敏感数据）。
应该：
- 指标与告警的最小集合（错误率、延迟、吞吐、资源）。
待办：
- 观测方案：[OBSERVABILITY_STACK]

### 6) 文档与变更说明
必须：
- 对外行为变化必须更新文档/说明（README、接口文档、使用示例）。
- 复杂决策必须留下记录（在 plan/research 或 ADR 风格记录中）。
应该：
- 提供 quickstart（本地启动、测试、常见问题）。
待办：
- 文档清单：[DOCS_LIST]


### 7) 例外流程（必须写清楚）
必须：
- 任何对规则的例外必须：说明原因、影响范围、补救措施、到期清理时间（timebox），并记录在 PR 或文档中。
- “临时跳过测试/lint”只能在紧急情况下使用，且必须补回归与补偿验证。


## 示例步骤2.功能规格说明（本次要做什么 + 验收标准）：
/speckit.specify 做一个本地 TODO 列表网页：可增删改、按完成状态筛选、数据保存在浏览器本地，不需要登录。

## 示例步骤3.（可选）需求澄清（提问补全）：
/speckit.clarify

## 示例步骤4.技术方案（怎么做）：
/speckit.plan 用 Vite + 原生 JS/HTML/CSS，不引入框架；用 localStorage 存储；写基础单元测试（如可行）。

## 示例步骤5.任务分解（可执行工单）：
/speckit.tasks

## 示例步骤6.实施交付（写代码并验证）：
/speckit.implement
---



## 0）这些命令在哪里运行？

- `/speckit.*` **不是** Linux 终端命令（bash/zsh 里运行会报 “没有那个文件或目录”）
- 它们是 **AI Agent（你选的 Codex CLI）交互界面**里的 *slash commands*
- 正确启动方式（在 shell 里做完再进入 codex）：

```bash
cd /home/pan/Desktop/code/test/spec_test
export CODEX_HOME="$PWD/.codex"
codex
```

> 说明：`CODEX_HOME` 用来让 Codex 加载项目里的 `.codex/`（其中包含 spec-kit 的 prompts / slash 命令定义）。通常改了 `.codex` 里的内容要重启 codex 会话才会生效。

---

## 1）`/speckit.constitution`：项目宪章（长期规则）

### 你应该怎么理解？

- 这是“项目宪法/团队原则”，长期有效  
- 不针对某个具体功能，而是规定开发质量、代码标准、测试策略等

### 作用是什么？

- 生成/更新项目的**长期原则**（比如测试、lint、代码风格、性能底线、简单优先等）
- 后续 `specify / plan / tasks / implement` 都会参考它，避免每次重复说明标准

### 你应该输入什么？

- 测试要求：必须有单测/集成测试、覆盖关键逻辑
- 工程规范：lint/format、目录结构、提交规范
- 设计原则：简单优先、可维护性优先、性能底线
- 安全/隐私：凭据不能入库、敏感信息处理

### 示例输入（✅ 你写的这句非常适合放这里）

```text
/speckit.constitution 我希望代码必须有测试、lint、清晰的目录结构；优先简单方案；性能和可维护性优先。
```

---

## 2）`/speckit.specify`：生成“规格说明（Spec）”（不是“需求澄清”）

### 你应该怎么理解？

- 这一步是把你要做的功能写成 **可验收的规格说明**  
- 包含：目标、范围、用户故事、验收标准、非目标、约束等  
- 它不是专门提问“澄清需求”的命令（澄清应使用 `/speckit.clarify`）

### 作用是什么？

- 为“本次要做的功能”生成一份 spec 文档
- 让需求从口头描述变成**可检查、可验收**的条目

### 你应该输入什么？

- 你要做的功能（What）
- 为什么做（Why/价值/场景）
- 成功/验收标准（Acceptance Criteria）
- 约束条件（离线、本地存储、不登录、平台限制）

### 示例输入（✅ 你这句非常合格）

```text
/speckit.specify 做一个本地 TODO 列表网页：可增删改、按完成状态筛选、数据保存在浏览器本地，不需要登录。
```

---

## 2.5）`/speckit.clarify`（可选但推荐）：需求澄清（这才是“澄清”）

### 你应该怎么理解？

- 在你不确定“细节怎么定”的时候，用它先问清楚  
- 例如：是否要排序？是否要标签？是否多列表？是否导入导出？空值/边界如何处理？

### 作用是什么？

- 产出一组澄清问题（边界条件、交互细节、数据模型、测试策略等）
- 你回答后会写入工件中，降低后面 plan/implement 返工概率

### 示例输入

```text
/speckit.clarify 请提出实现前必须澄清的问题，覆盖数据模型、UI交互、边界条件与测试策略。
```

---

## 3）`/speckit.plan`：技术方案/实现计划（把 “做什么” 变成 “怎么做”）

### 你应该怎么理解？

- 你输入的技术栈只是“约束/偏好”
- `plan` 会据此产出 **可执行的技术实现方案**
- 这一步输出通常会包括：架构/模块划分、数据模型、UI结构、测试策略、风险点等

### 作用是什么？

- 输出完整实现计划（Implementation Plan）：架构/模块划分、数据模型、页面/组件结构、测试策略、风险点等
- 为下一步 tasks 拆解提供依据（让任务可执行、可验收）

### 你应该输入什么？

- 技术栈偏好：Vite、原生还是 TS、测试框架（Vitest/Playwright）
- 存储方案：localStorage / IndexedDB
- 约束：尽量少依赖、性能底线、兼容性要求
- 工程实践：是否要求 TDD、是否需要 CI

### 示例输入（✅ 你这句作为 plan 的“约束输入”是 OK 的）

```text
/speckit.plan 用 Vite + 原生 JS/HTML/CSS，不引入框架；用 localStorage 存储；写基础单元测试（如可行）。
```

---

## 4）`/speckit.tasks`：任务拆解（把 plan 变成工单/步骤）

### 你应该怎么理解？

- 它会把 plan 拆成 **可执行任务清单**
- 通常包含依赖顺序、每个任务改哪些文件、如何验证

### 参数怎么传？

- 一般不需要参数，直接运行：

```text
/speckit.tasks
```

### 输出/影响是什么？

- 生成 `tasks.md`（或类似任务清单文件）
- 后续 implement 会按它执行

---

## 5）`/speckit.implement`：实施（按 tasks 真正写代码并验证）

### 你应该怎么理解？

- 这是“开工+交付”阶段
- 会按 tasks 顺序进行代码修改，并运行你本机的测试/lint/build 等命令（视模板/项目而定）

### 参数怎么传？

- 通常不需要参数，直接运行：

```text
/speckit.implement
```

### 输出/影响是什么？

- 真实落地：创建/修改代码文件、执行命令、完成实现
- 最后给你总结与下一步建议

---

## 6）你的流程“正确版本”应该这样标注（✅ 推荐你这样记）


---

## 7）省略



## 8）关于 `/speckit.*` 和 `/prompts:speckit.*`：什么时候用哪个？

- 如果你的 Codex 菜单里直接出现 `/speckit.constitution`，就用 `/speckit.*`（更短）
- 如果识别不了（Unknown command），就用更通用的形式：

```text
/prompts:speckit.constitution ...
/prompts:speckit.specify ...
/prompts:speckit.clarify ...
/prompts:speckit.plan ...
/prompts:speckit.tasks
/prompts:speckit.implement
```

---

## 9）“参数怎么传”的通用规则（你最关心的点）

- 对 speckit 命令来说，大多数“参数”就是：**命令后面跟一段自然语言描述**
  - `constitution`：长期原则/质量标准（写一段话）
  - `specify`：功能需求 + 约束 + 验收标准（写一段话）
  - `clarify`：告诉它重点澄清哪些方面（写一段话或直接运行）
  - `plan`：技术栈/实现约束/测试策略偏好（写一段话）
  - `tasks`：一般不需要参数
  - `implement`：一般不需要参数

- 如果你将来遇到某些 Codex prompt 需要“命名参数”，典型格式是：
  - `KEY=value`（有空格用引号）
  - 例如：`/prompts:xxx FILES="..." PR_TITLE="..."`

---

## 10）如果你想验证是否“真的生效”，建议你检查这些产物（可选）

在 shell 里（不在 codex 里）：

```bash
cd /home/pan/Desktop/code/test/spec_test
find .specify -maxdepth 4 -type f | sed 's#^#- #'
```

你通常会看到：

- `.specify/memory/constitution.md`（宪章）
- `.specify/specs/<id-名称>/spec.md`（规格）
- `.specify/specs/<id-名称>/plan.md`（计划）
- `.specify/specs/<id-名称>/tasks.md`（任务）
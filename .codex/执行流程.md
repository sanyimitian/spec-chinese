# GitHub Spec Kit（spec-kit）怎么用：在 Codex 里运行哪些命令、怎么传参、分别有什么作用


> 流水线：**宪章（长期规则）→ 规格说明（本次要做什么）→（可选）澄清问题 → 技术方案 → 任务拆解 → 实施落地**。

---

首先在终端执行以下命令，让codex可以识别 Spec Kit 的命令

export CODEX_HOME=【Spec Kit 初始化出来的项目目录】/.codex

例如：export CODEX_HOME= /home/pan/Desktop/code/test/spec_demo/.codex

## 0）这些命令在哪里运行？

- `/speckit.*` **不是** Linux 终端命令（bash/zsh 里运行会报 “没有那个文件或目录”）
- 它们是 **AI Agent（你选的 Codex CLI）交互界面**里的 *slash commands*
- 正确启动方式（在 shell 里做完再进入 codex）：

```bash
cd /home/pan/Desktop/code/test/spec_test
export CODEX_HOME="$PWD/.codex"
codex
```

> 说明：`CODEX_HOME` 用来让 Codex 加载项目里的 `.codex/`（其中包含 spec-kit 的 prompts / slash 命令定义）。通常改了 `.codex` 里的内容要重启 codex 会话才会生效。

---

## 1）`/speckit.constitution`：项目宪章（长期规则）

### 你应该怎么理解？

- 这是“项目宪法/团队原则”，长期有效  
- 不针对某个具体功能，而是规定开发质量、代码标准、测试策略等

### 作用是什么？

- 生成/更新项目的**长期原则**（比如测试、lint、代码风格、性能底线、简单优先等）
- 后续 `specify / plan / tasks / implement` 都会参考它，避免每次重复说明标准

### 你应该输入什么？

- 测试要求：必须有单测/集成测试、覆盖关键逻辑
- 工程规范：lint/format、目录结构、提交规范
- 设计原则：简单优先、可维护性优先、性能底线
- 安全/隐私：凭据不能入库、敏感信息处理

### 示例输入（✅ 你写的这句非常适合放这里）

```text
/speckit.constitution 我希望代码必须有测试、lint、清晰的目录结构；优先简单方案；性能和可维护性优先。
```

---

## 2）`/speckit.specify`：生成“规格说明（Spec）”（不是“需求澄清”）

### 你应该怎么理解？

- 这一步是把你要做的功能写成 **可验收的规格说明**  
- 包含：目标、范围、用户故事、验收标准、非目标、约束等  
- 它不是专门提问“澄清需求”的命令（澄清应使用 `/speckit.clarify`）

### 作用是什么？

- 为“本次要做的功能”生成一份 spec 文档
- 让需求从口头描述变成**可检查、可验收**的条目

### 你应该输入什么？

- 你要做的功能（What）
- 为什么做（Why/价值/场景）
- 成功/验收标准（Acceptance Criteria）
- 约束条件（离线、本地存储、不登录、平台限制）

### 示例输入（✅ 你这句非常合格）

```text
/speckit.specify 做一个本地 TODO 列表网页：可增删改、按完成状态筛选、数据保存在浏览器本地，不需要登录。
```

---

## 2.5）`/speckit.clarify`（可选但推荐）：需求澄清（这才是“澄清”）

### 你应该怎么理解？

- 在你不确定“细节怎么定”的时候，用它先问清楚  
- 例如：是否要排序？是否要标签？是否多列表？是否导入导出？空值/边界如何处理？

### 作用是什么？

- 产出一组澄清问题（边界条件、交互细节、数据模型、测试策略等）
- 你回答后会写入工件中，降低后面 plan/implement 返工概率

### 示例输入

```text
/speckit.clarify 请提出实现前必须澄清的问题，覆盖数据模型、UI交互、边界条件与测试策略。
```

---

## 3）`/speckit.plan`：技术方案/实现计划（把 “做什么” 变成 “怎么做”）

### 你应该怎么理解？

- 你输入的技术栈只是“约束/偏好”
- `plan` 会据此产出 **可执行的技术实现方案**
- 这一步输出通常会包括：架构/模块划分、数据模型、UI结构、测试策略、风险点等

### 作用是什么？

- 输出完整实现计划（Implementation Plan）：架构/模块划分、数据模型、页面/组件结构、测试策略、风险点等
- 为下一步 tasks 拆解提供依据（让任务可执行、可验收）

### 你应该输入什么？

- 技术栈偏好：Vite、原生还是 TS、测试框架（Vitest/Playwright）
- 存储方案：localStorage / IndexedDB
- 约束：尽量少依赖、性能底线、兼容性要求
- 工程实践：是否要求 TDD、是否需要 CI

### 示例输入（✅ 你这句作为 plan 的“约束输入”是 OK 的）

```text
/speckit.plan 用 Vite + 原生 JS/HTML/CSS，不引入框架；用 localStorage 存储；写基础单元测试（如可行）。
```

---

## 4）`/speckit.tasks`：任务拆解（把 plan 变成工单/步骤）

### 你应该怎么理解？

- 它会把 plan 拆成 **可执行任务清单**
- 通常包含依赖顺序、每个任务改哪些文件、如何验证

### 参数怎么传？

- 一般不需要参数，直接运行：

```text
/speckit.tasks
```

### 输出/影响是什么？

- 生成 `tasks.md`（或类似任务清单文件）
- 后续 implement 会按它执行

---

## 5）`/speckit.implement`：实施（按 tasks 真正写代码并验证）

### 你应该怎么理解？

- 这是“开工+交付”阶段
- 会按 tasks 顺序进行代码修改，并运行你本机的测试/lint/build 等命令（视模板/项目而定）

### 参数怎么传？

- 通常不需要参数，直接运行：

```text
/speckit.implement
```

### 输出/影响是什么？

- 真实落地：创建/修改代码文件、执行命令、完成实现
- 最后给你总结与下一步建议

---

## 6）你的流程“正确版本”应该这样标注（✅ 推荐你这样记）

- **初始化宪章（长期规则）**：`/speckit.constitution ...`
- **生成规格说明（本次功能需求 + 验收标准）**：`/speckit.specify ...`
- **（可选）需求澄清（提问补全不确定点）**：`/speckit.clarify ...`
- **规划技术方案（怎么实现）**：`/speckit.plan ...`
- **拆解任务（施工清单/工单化）**：`/speckit.tasks`
- **实施交付（写代码 + 验证）**：`/speckit.implement`

---

## 7）你的示例流程：能跑，但建议加上 clarify（更稳）

### 你原来的写法（✅ 基本可用）

```text
/speckit.constitution 我希望代码必须有测试、lint、清晰的目录结构；优先简单方案；性能和可维护性优先。
/speckit.specify 做一个本地 TODO 列表网页：可增删改、按完成状态筛选、数据保存在浏览器本地，不需要登录。
/speckit.plan 用 Vite + 原生 JS/HTML/CSS，不引入框架；用 localStorage 存储；写基础单元测试（如可行）。
/speckit.tasks
/speckit.implement
```

### 推荐升级版（✅ 返工更少）

```text
/speckit.constitution 代码必须通过 lint 与测试；优先简单可维护；目录结构清晰；新增功能必须有测试或可验证步骤；避免引入不必要依赖。
/speckit.specify 做一个离线可用的本地 TODO 网页应用：支持新增/编辑/删除/完成；支持按完成状态筛选；数据持久化到浏览器本地；不需要登录。请给出清晰验收标准与非目标。
/speckit.clarify 请提出实现前必须澄清的问题，覆盖数据模型、UI交互、边界条件与测试策略。
/speckit.plan 使用 Vite + 原生 JS/HTML/CSS（必要时可用 TypeScript）；localStorage 持久化；使用 Vitest 做基础单测；尽量少依赖。
/speckit.tasks
/speckit.implement
```

---

## 8）关于 `/speckit.*` 和 `/prompts:speckit.*`：什么时候用哪个？

- 如果你的 Codex 菜单里直接出现 `/speckit.constitution`，就用 `/speckit.*`（更短）
- 如果识别不了（Unknown command），就用更通用的形式：

```text
/prompts:speckit.constitution ...
/prompts:speckit.specify ...
/prompts:speckit.clarify ...
/prompts:speckit.plan ...
/prompts:speckit.tasks
/prompts:speckit.implement
```

---

## 9）“参数怎么传”的通用规则（你最关心的点）

- 对 speckit 命令来说，大多数“参数”就是：**命令后面跟一段自然语言描述**
  - `constitution`：长期原则/质量标准（写一段话）
  - `specify`：功能需求 + 约束 + 验收标准（写一段话）
  - `clarify`：告诉它重点澄清哪些方面（写一段话或直接运行）
  - `plan`：技术栈/实现约束/测试策略偏好（写一段话）
  - `tasks`：一般不需要参数
  - `implement`：一般不需要参数

- 如果你将来遇到某些 Codex prompt 需要“命名参数”，典型格式是：
  - `KEY=value`（有空格用引号）
  - 例如：`/prompts:xxx FILES="..." PR_TITLE="..."`

---

## 10）如果你想验证是否“真的生效”，建议你检查这些产物（可选）

在 shell 里（不在 codex 里）：

```bash
cd /home/pan/Desktop/code/test/spec_test
find .specify -maxdepth 4 -type f | sed 's#^#- #'
```

你通常会看到：

- `.specify/memory/constitution.md`（宪章）
- `.specify/specs/<id-名称>/spec.md`（规格）
- `.specify/specs/<id-名称>/plan.md`（计划）
- `.specify/specs/<id-名称>/tasks.md`（任务）
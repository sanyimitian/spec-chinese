---
description: 从自然语言的功能描述创建或更新功能规范。
handoffs: 
  - label: 构建技术计划
    agent: speckit.plan
    prompt: 为规范创建计划。我使用的技术栈是...
  - label: 澄清规范需求
    agent: speckit.clarify
    prompt: 澄清规范需求
    send: true
---

## 用户输入

```text
$ARGUMENTS
```

在继续之前你**必须**先考虑用户输入（如果不为空）。

## 大纲

用户在触发消息中 `/speckit.specify` 之后输入的文本**就是**功能描述。即便 `$ARGUMENTS` 在下方以字面形式出现，也假设该描述始终可在本对话中取得。除非用户提供空命令，否则不要要求其重复。

给定该功能描述，执行以下操作：

1. **生成简洁短名**（2-4 个词）用于分支：
   - 分析功能描述并提取最关键的关键词
   - 创建 2-4 个词的短名，抓住功能本质
   - 尽量使用动词-名词格式（如 "add-user-auth"、"fix-payment-bug"）
   - 保留技术术语与缩写（OAuth2、API、JWT 等）
   - 简洁但具有可读性
   - 示例：
     - "我想添加用户认证" → "user-auth"
     - "为 API 实现 OAuth2 集成" → "oauth2-api-integration"
     - "创建一个分析看板" → "analytics-dashboard"
     - "修复支付处理超时问题" → "fix-payment-timeout"

2. **创建新分支前检查已有分支**：

   a. 先获取所有远程分支，确保信息最新：

      ```bash
      git fetch --all --prune
      ```

   b. 找到该 short-name 在所有来源中的最大功能编号：
      - 远程分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - specs 目录：检查 `specs/[0-9]+-<short-name>`

   c. 确定下一个可用编号：
      - 从三处提取所有编号
      - 找到最大编号 N
      - 新分支编号使用 N+1

   d. 使用计算后的编号和短名运行 `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS"`：
      - 传入 `--number N+1` 与 `--short-name "your-short-name"`，并携带功能描述
      - Bash 示例：`.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" --json --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShell 示例：`.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS" -Json -Number 5 -ShortName "user-auth" "Add user authentication"`

   **重要**：
   - 必须检查远程分支、本地分支、specs 目录以确定最高编号
   - 仅匹配与 short-name 模式完全一致的分支/目录
   - 若未找到该 short-name 的分支/目录，从编号 1 开始
   - 每个功能只能运行一次该脚本
   - JSON 输出会显示在终端中——务必以它为准获取真正的内容
   - JSON 输出包含 BRANCH_NAME 与 SPEC_FILE 路径
   - 对于参数中包含单引号（如 "I'm Groot"），使用转义语法：例如 'I'\''m Groot'（或尽量用双引号："I'm Groot"）

3. 加载 `.specify/templates/spec-template.md` 了解必需章节。

4. 按以下流程执行：

    1. 从输入中解析用户描述
       若为空：ERROR "未提供功能描述"
    2. 从描述中提取关键概念
       识别：参与者、动作、数据、约束
    3. 对不明确之处：
       - 基于上下文与行业惯例作合理猜测
       - 仅在以下情况标记 [NEEDS CLARIFICATION: specific question]：
         - 该选择显著影响功能范围或用户体验
         - 存在多种合理解释且影响不同
         - 没有合理默认值
       - **限制：最多 3 个 [NEEDS CLARIFICATION] 标记**
       - 优先级：范围 > 安全/隐私 > 用户体验 > 技术细节
    4. 填写 User Scenarios & Testing 章节
       若无清晰用户流程：ERROR "无法确定用户场景"
    5. 生成功能需求
       每条需求必须可测试
       对未指定细节使用合理默认值（在 Assumptions 章节记录）
    6. 定义成功标准
       创建可衡量、技术无关的结果
       包含量化指标（时间、性能、数量）与定性指标（用户满意度、任务完成率）
       每条标准必须可在无实现细节情况下验证
    7. 识别关键实体（若涉及数据）
    8. 返回：SUCCESS（规范可用于规划）

5. 使用模板结构将规范写入 SPEC_FILE，以功能描述（参数）生成具体内容并保留章节顺序与标题。

6. **规范质量校验**：写入初稿后，根据质量标准进行校验：

   a. **创建规范质量清单**：在 `FEATURE_DIR/checklists/requirements.md` 使用清单模板结构生成以下校验项：

      ```markdown
      # 规范质量清单：[功能名称]
      
      **目的**：在进入规划前验证规范的完整性与质量
      **创建时间**：[DATE]
      **功能**：[Link to spec.md]
      
      ## 内容质量
      
      - [ ] 不包含实现细节（语言、框架、API）
      - [ ] 聚焦用户价值与业务需求
      - [ ] 面向非技术干系人撰写
      - [ ] 所有必需章节已完成
      
      ## 需求完整性
      
      - [ ] 不再存在 [NEEDS CLARIFICATION] 标记
      - [ ] 需求可测试且无歧义
      - [ ] 成功标准可衡量
      - [ ] 成功标准技术无关（不含实现细节）
      - [ ] 所有验收场景已定义
      - [ ] 已识别边界情况
      - [ ] 范围界定清晰
      - [ ] 已识别依赖与假设
      
      ## 功能就绪度
      
      - [ ] 所有功能需求都有清晰验收标准
      - [ ] 用户场景覆盖主流程
      - [ ] 功能满足成功标准中定义的可衡量结果
      - [ ] 规范中不包含实现细节
      
      ## 备注
      
      - 标记为未完成的项需在 `/speckit.clarify` 或 `/speckit.plan` 前更新规范
      ```

   b. **运行校验检查**：逐项检查清单：
      - 对每项判定通过/失败
      - 记录发现的具体问题（引用相关规范段落）

   c. **处理校验结果**：

      - **若全部通过**：标记清单完成并进入步骤 6

      - **若有失败（不含 [NEEDS CLARIFICATION]）**：
        1. 列出失败项及具体问题
        2. 更新规范以解决问题
        3. 反复校验直到全部通过（最多 3 次）
        4. 若 3 次后仍失败，在清单备注中记录剩余问题并提示用户

      - **若仍有 [NEEDS CLARIFICATION] 标记**：
        1. 从规范中提取所有 [NEEDS CLARIFICATION: ...] 标记
        2. **限制检查**：若超过 3 个，只保留影响最大的 3 个（按范围/安全/UX 影响），其余做合理猜测
        3. 对每个澄清问题（最多 3 个），按以下格式向用户给出选项：

           ```markdown
           ## 问题 [N]：[主题]
           
           **上下文**：[引用相关规范段落]
           
           **需要确认**：[来自 NEEDS CLARIFICATION 标记的具体问题]
           
           **建议答案**：
           
           | 选项 | 答案 | 影响 |
           |------|------|------|
           | A    | [建议答案一] | [对功能的影响] |
           | B    | [建议答案二] | [对功能的影响] |
           | C    | [建议答案三] | [对功能的影响] |
           | 自定义 | 提供自己的答案 | [如何提供自定义输入] |
           
           **你的选择**：_[等待用户回复]_
           ```

        4. **关键 - 表格格式**：确保 Markdown 表格正确渲染：
           - 管道符间距一致对齐
           - 单元格内容两侧有空格：`| Content |`，而不是 `|Content|`
           - 表头分隔线至少 3 个短横：`|--------|`
           - 确认预览渲染正确
        5. 问题顺序编号（Q1、Q2、Q3，最多 3 个）
        6. 一次性展示所有问题再等待回复
        7. 等待用户对所有问题的选择（如 "Q1: A, Q2: 自定义 - [details], Q3: B"）
        8. 用用户选择/提供的答案替换每个 [NEEDS CLARIFICATION] 标记
        9. 所有澄清解决后再次运行校验

   d. **更新清单**：每次校验迭代后，更新清单文件中的通过/失败状态

7. 汇报完成：分支名、规范文件路径、清单结果，以及下一阶段就绪状态（`/speckit.clarify` 或 `/speckit.plan`）。

**注意：**脚本会创建并切换到新分支，并在写入前初始化规范文件。

## 通用指南

## 快速指南

- 关注用户**需要什么**以及**为什么**。
- 避免描述如何实现（不写技术栈、API、代码结构）。
- 面向业务干系人写作，而不是开发者。
- 不要在规范中嵌入任何清单（清单由单独命令生成）。

### 章节要求

- **必需章节**：每个功能都必须完成
- **可选章节**：仅在与功能相关时包含
- 当某章节不适用时，移除该章节（不要写 "N/A"）

### AI 生成规范时

1. **合理猜测**：使用上下文、行业标准与常见模式填补缺口
2. **记录假设**：在 Assumptions 章节记录合理默认值
3. **限制澄清**：最多 3 个 [NEEDS CLARIFICATION] 标记，仅用于关键决策：
   - 显著影响功能范围或用户体验
   - 存在多种合理解释且影响不同
   - 没有合理默认值
4. **优先级**：范围 > 安全/隐私 > 用户体验 > 技术细节
5. **像测试员思考**：任何含糊需求都应无法通过“可测试且无歧义”检查
6. **常见需要澄清的区域**（仅在无合理默认值时）：
   - 功能范围与边界（包含/排除的用例）
   - 用户类型与权限（存在多种冲突解释时）
   - 安全/合规要求（法律/财务影响显著时）

**合理默认值示例**（不要因此提问）：

- 数据保留：符合领域通用实践
- 性能目标：默认 Web/移动应用标准期望
- 错误处理：用户友好提示与适当回退
- 认证方式：Web 应用默认会话或 OAuth2
- 集成模式：默认 RESTful API

### 成功标准指南

成功标准必须满足：

1. **可衡量**：包含具体指标（时间、百分比、数量、比率）
2. **技术无关**：不提框架、语言、数据库、工具
3. **以用户为中心**：描述用户/业务结果，而非系统内部
4. **可验证**：无需实现细节即可测试/验证

**好的示例**：

- "用户可在 3 分钟内完成结账"
- "系统支持 10,000 并发用户"
- "95% 的搜索在 1 秒内返回结果"
- "任务完成率提升 40%"
**坏的示例**（实现导向）：

- \"API 响应时间低于 200ms\"（过于技术性，可改为“用户看到结果几乎是即时的”）
- \"数据库可处理 1000 TPS\"（实现细节，可改为面向用户的指标）
- \"React 组件渲染高效\"（框架特定）
- \"Redis 缓存命中率高于 80%\"（技术特定）
